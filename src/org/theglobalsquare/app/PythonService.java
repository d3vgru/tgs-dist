/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// adapted from org.renpy.android.SDLSurfaceView

// This string is autogenerated by ChangeAppSettings.sh, do not change spaces amount
package org.theglobalsquare.app;


import org.renpy.android.ResourceManager;

import android.app.Activity;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.util.Log;
import android.view.MotionEvent;
import android.view.KeyEvent;
import android.net.Uri;
import android.os.IBinder;
import android.os.PowerManager;

import java.io.IOException;
import java.io.InputStream;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import java.nio.FloatBuffer;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import android.graphics.Color;
import android.content.res.Resources;


public class PythonService extends Service implements Runnable {
	private static String TAG = "SDLSurface";
    private final String mVertexShader =
        "uniform mat4 uMVPMatrix;\n" +
        "attribute vec4 aPosition;\n" +
        "attribute vec2 aTextureCoord;\n" +
        "varying vec2 vTextureCoord;\n" +
        "void main() {\n" +
        "  gl_Position = uMVPMatrix * aPosition;\n" +
        "  vTextureCoord = aTextureCoord;\n" +
        "}\n";

    private final String mFragmentShader =
        "precision mediump float;\n" +
        "varying vec2 vTextureCoord;\n" +
        "uniform sampler2D sTexture;\n" +
        "void main() {\n" +
        "  gl_FragColor = texture2D(sTexture, vTextureCoord);\n" +

        "}\n";

    // The activity we're a part of.
    // FIXME probably don't need this
    private static Activity mActivity;

    // Have we started yet?
    public boolean mStarted = false;

    // Is Python ready to receive input events?
    static boolean mInputActivated = false;

    // The number of times we should clear the screen after swap.
    private int mClears = 2;

    // Has the display been changed?
    private boolean mChanged = false;

    // Are we running yet?
    private boolean mRunning = false;

    // The user program is not participating in the pause protocol.
    static int PAUSE_NOT_PARTICIPATING = 0;

    // A pause has not been requested by the OS.
    static int PAUSE_NONE = 1;

    // A pause has been requested by Android, but the user program has
    // not bothered responding yet.
    static int PAUSE_REQUEST = 2;

    // The user program is waiting in waitForResume.
    static int PAUSE_WAIT_FOR_RESUME = 3;

	static int PAUSE_STOP_REQUEST = 4;
	static int PAUSE_STOP_ACK = 5;

    // This stores the state of the pause system.
    static int mPause = PAUSE_NOT_PARTICIPATING;

    private PowerManager.WakeLock wakeLock;

    // The name of the directory where the context stores its files.
    String mFilesDirectory = null;

    // The value of the argument passed in.
    String mArgument = null;

    // The resource manager we use.
    ResourceManager mResourceManager;

	// Our own view
	static PythonService instance = null;

    public PythonService(Activity act, String argument) {
        super();

		PythonService.instance = this;

        mActivity = act;
        mResourceManager = new ResourceManager(act);

        mFilesDirectory = mActivity.getFilesDir().getAbsolutePath();
        mArgument = argument;

        PowerManager pm = (PowerManager) act.getSystemService(Context.POWER_SERVICE);
        wakeLock = pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK, "Screen On");
    }


    /**
     * The user program should call this frequently to check if a
     * pause has been requested by android. If this ever returns
     * true, the user program should clean up and call waitForResume.
     */
    public int checkPause() {
        if (mPause == PAUSE_NOT_PARTICIPATING) {
            mPause = PAUSE_NONE;
        }

        if (mPause == PAUSE_REQUEST) {
            return 1;
        } else {
            return 0;
        }
    }


    /**
     * The user program should call this quickly after checkPause
     * returns true. This causes the android application to sleep,
     * waiting for resume. While sleeping, it should not have any
     * activity. (Notably, it should stop all timers.)
     *
     * While we're waiting in this method, android is allowed to
     * kill us to reclaim memory, without any further warning.
     */
    public void waitForResume() {
        synchronized (this) {
            mPause = PAUSE_WAIT_FOR_RESUME;

            // Notify any threads waiting in onPause.
            this.notifyAll();

            while (mPause == PAUSE_WAIT_FOR_RESUME) {
                try {
                    this.wait();
                } catch (InterruptedException e) {
                }
            }
        }
        setOpenFile();
    }

    /**
     * if the activity was called with a file parameter, put it in the
     * 'PYTHON_OPENFILE' env var
     */
    public static void setOpenFile(){
        final android.content.Intent intent = mActivity.getIntent();
        if (intent != null) {
            final android.net.Uri data = intent.getData();
            if (data != null && data.getEncodedPath() != null){
                nativeSetEnv("PYTHON_OPENFILE", data.getEncodedPath());
            }
        }
    }

    /**
     * Inform the view that the activity is paused. The owner of this view must
     * call this method when the activity is paused. Calling this method will
     * pause the rendering thread.
     * Must not be called before a renderer has been set.
     */
    public void onPause() {

        synchronized (this) {
            if (mPause == PAUSE_NONE) {
                mPause = PAUSE_REQUEST;

                while (mPause == PAUSE_REQUEST) {
                    try {
                        this.wait();
                    } catch (InterruptedException e) {
                        // pass
                    }
                }
            }
        }

        wakeLock.release();

    }

    /**
     * Inform the view that the activity is resumed. The owner of this view must
     * call this method when the activity is resumed. Calling this method will
     * recreate the OpenGL display and resume the rendering
     * thread.
     * Must not be called before a renderer has been set.
     */
    public void onResume() {
        synchronized (this) {
            if (mPause == PAUSE_WAIT_FOR_RESUME) {
                mPause = PAUSE_NONE;
                this.notifyAll();
            }
        }
        wakeLock.acquire();
    }

	public void onDestroy() {
		Log.w(TAG, "onDestroy() called");
		synchronized (this) {
			this.notifyAll();

			if ( mPause == PAUSE_STOP_ACK ) {
				Log.d(TAG, "onDestroy() app already leaved.");
				return;
			}

			// application didn't leave, give 10s before closing.
			// hopefully, this could be enough for launching the on_stop() trigger within the app.
			mPause = PAUSE_STOP_REQUEST;
			int i = 50;

			Log.d(TAG, "onDestroy() stop requested, wait for an event from the app");
			for (; i >= 0 && mPause == PAUSE_STOP_REQUEST; i--) {
				try {
					this.wait(200);
				} catch (InterruptedException e) {
					break;
				}
			}
			Log.d(TAG, "onDestroy() stop finished waiting.");
		}
	}

	static int checkStop() {
        if (mPause == PAUSE_STOP_REQUEST)
			return 1;
		return 0;
	}

	static void ackStop() {
		Log.d(TAG, "ackStop() notify");
		synchronized (instance) {
			mPause = PAUSE_STOP_ACK;
			instance.notifyAll();
		}
	}

    public void run() {
		waitForStart();

//        nativeResize(mWidth, mHeight);
        nativeInitJavaCallbacks();
        nativeSetEnv("ANDROID_PRIVATE", mFilesDirectory);
        nativeSetEnv("ANDROID_ARGUMENT", mArgument);
        nativeSetEnv("PYTHONOPTIMIZE", "2");
        nativeSetEnv("PYTHONHOME", mFilesDirectory);
        nativeSetEnv("PYTHONPATH", mArgument + ":" + mFilesDirectory + "/lib");

		// XXX Using SetOpenFile make a crash in nativeSetEnv. I don't
		// understand why, maybe because the method is static or something.
		// Anyway, if you remove that part of the code, ensure the Laucher
		// (ProjectChooser) is still working.
        /*
		final android.content.Intent intent = mActivity.getIntent();
		if (intent != null) {
			final android.net.Uri data = intent.getData();
			if (data != null && data.getEncodedPath() != null)
				nativeSetEnv("PYTHON_OPENFILE", data.getEncodedPath());
		}
		*/

//		nativeSetMultitouchUsed();
        nativeInit();

		mPause = PAUSE_STOP_ACK;

		//Log.i(TAG, "End of native init, stop everything (exit0)");
        System.exit(0);
    }

    private void waitForStart() {

        int presplashId = mResourceManager.getIdentifier("presplash", "drawable");
        InputStream is = mActivity.getResources().openRawResource(presplashId);

        Bitmap bitmap = null;
        try {
            bitmap = BitmapFactory.decodeStream(is);
			bitmap = bitmap.copy(Bitmap.Config.ARGB_8888, false);
        } finally {
            try {
                is.close();
            } catch (IOException e) { }
        }
        // Wait to be notified it's okay to start Python.
        synchronized (this) {
            while (!mStarted) {
                try {
                    this.wait(250);
                } catch (InterruptedException e) {
                    continue;
                }
            }
        }
    }


    // does this do anything useful in a service context?
    public void start() {
        synchronized (this) {
            mStarted = true;
            this.notify();
        }
    }

    /* might need this back later?
	private static final int INVALID_POINTER_ID = -1;
	private int mActivePointerId = INVALID_POINTER_ID;

    @Override
    public boolean onTouchEvent(final MotionEvent event) {

		if (mInputActivated == false)
			return true;

		int action = event.getAction() & MotionEvent.ACTION_MASK;
		int sdlAction = -1;
		int pointerId = -1;
		int pointerIndex = -1;

		switch ( action ) {
			case MotionEvent.ACTION_DOWN:
			case MotionEvent.ACTION_POINTER_DOWN:
				sdlAction = 0;
				break;
			case MotionEvent.ACTION_MOVE:
				sdlAction = 2;
				break;
			case MotionEvent.ACTION_UP:
			case MotionEvent.ACTION_POINTER_UP:
				sdlAction = 1;
				break;
		}

		// http://android-developers.blogspot.com/2010/06/making-sense-of-multitouch.html
		switch ( action  & MotionEvent.ACTION_MASK ) {
			case MotionEvent.ACTION_DOWN:
			case MotionEvent.ACTION_MOVE:
			case MotionEvent.ACTION_UP:
				pointerIndex = event.findPointerIndex(mActivePointerId);
				break;
			case MotionEvent.ACTION_POINTER_DOWN:
			case MotionEvent.ACTION_POINTER_UP:
				pointerIndex = (event.getAction() & MotionEvent.ACTION_POINTER_INDEX_MASK)
					>> MotionEvent.ACTION_POINTER_INDEX_SHIFT;
				if ( action == MotionEvent.ACTION_POINTER_UP ) {
					pointerId = event.getPointerId(pointerIndex);
					if ( pointerId == mActivePointerId )
						mActivePointerId = event.getPointerId(pointerIndex == 0 ? 1 : 0);
				}
				break;
		}

		if ( sdlAction >= 0 ) {

			for ( int i = 0; i < event.getPointerCount(); i++ ) {

				if ( pointerIndex == -1 || pointerIndex == i ) {

					/**
        			Log.i("python", String.format("mouse id=%d action=%d x=%f y=%f",
							event.getPointerId(i),
							sdlAction,
							event.getX(i),
							event.getY(i)
					));
					**/
    /*  might need this back later?
					PythonService.nativeMouse(
							(int)event.getX(i),
							(int)event.getY(i),
							sdlAction,
							event.getPointerId(i),
							(int)(event.getPressure(i) * 1000.0),
							(int)(event.getSize(i) * 1000.0));
				}

			}

		}

        return true;
    };

    @Override
    public boolean onKeyDown(int keyCode, final KeyEvent event) {
        //Log.i("python", String.format("key down %d", keyCode));
        if (mInputActivated && nativeKey(keyCode, 1, event.getUnicodeChar())) {
            return true;
        } else {
            return super.onKeyDown(keyCode, event);
        }
    }

    @Override
    public boolean onKeyUp(int keyCode, final KeyEvent event) {
        //Log.i("python", String.format("key up %d", keyCode));
        if (mInputActivated && nativeKey(keyCode, 0, event.getUnicodeChar())) {
            return true;
        } else {
            return super.onKeyUp(keyCode, event);
        }
    }

    static void activateInput() {
        mInputActivated = true;
    }
    */

	static void openUrl(String url) {
		Log.i("python", "Opening URL: " + url);

		Intent i = new Intent(Intent.ACTION_VIEW);
		i.setData(Uri.parse(url));
		mActivity.startActivity(i);
	}

	// Native part

    public static native void nativeSetEnv(String name, String value);
    public static native void nativeInit();

    public static native void nativeMouse( int x, int y, int action, int pointerId, int pressure, int radius );
    public static native boolean nativeKey(int keyCode, int down, int unicode);
    public static native void nativeSetMouseUsed();
    public static native void nativeSetMultitouchUsed();

    public native void nativeResize(int width, int height);
    public native void nativeInitJavaCallbacks();


	@Override
	public IBinder onBind(Intent arg0) {
		// FIXME startup and bind to the python module
		return null;
	}

}
